---
title: "Redux Toolkit Query 사용 후기"
description: "Redux Toolkit Query를 사용하면서 마주친 문제 해결 과정을 작성했습니다."
image:
createdAt: "2023-01-15T14:51:13.162Z"
updatedAt:
author: "nw.lee"
draft: false
tags: ["Redux Toolkit", "RTK Query", "트러블슈팅"]
---

Redux Toolkit Query는 데이터를 불러오거나 캐시하는 로직을 직접 작성할 필요를 제거해주는 라이브러리이다. Redux Toolkit 패키지에 포함되어있기 때문에 상태 관리 로직에 연동시킬 수도 있다.

기초적인 사용 사례는 다음과 같을 것이다.

```typescript
const gameApi = createApi({
  reducerPath: "gameApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "API Address",
    prepareHeaders(headers) {
      headers.append("Authorization", "ACCESS TOKEN")
      return headers
    }
  })
  endpoints: (builder) => ({
    getGames: builder.query<ResponseType, QueryParameter>({
      query: (props: QueryParameter) => {
        return "Unique Endpoint"
      }
    })
  })
})
```

`reducerPath`에는 다른 리듀서와 구별되는 문자열을 작성한다. `baseQuery` 속성에는 `fetchBaseQuery` 함수를 통해 헤더에 특정 속성을 추가하고, `baseUrl` 속성에 서버 URL을 명시할 수 있다.
`endpoints` 속성에는 각 API에 엔드포인트 URL을 명시하여 쿼리 및 뮤테이션을 작성할 수 있다.

`builder.query` 메소드에는 응답 데이터에 대한 타입을 지정할 수 있다. 별다른 설정을 하지 않았을 경우 명시된 타입이 실제 API 응답 데이터의 구조와 일치해야 한다.

여러 프로젝트에서 RTK Query를 사용했고 마주친 문제 상황에서 어떻게 해결했는지 작성해뵜다.

## 응답 데이터와 타입이 맞지 않는 경우

`transformResponse` 메소드를 정의하여 응답 데이터를 타입에 맞게 변경할 수 있다.

```typescript
getGames: builder.query<ResponseType, QueryParameter>({
  query: (props: QueryParameter) => {
    return "Endpoint";
  },
  transformResponse(response: any, meta, arg) {
    return response.someData as ResponseType;
  },
});
```

## RTK Query로 받아온 데이터를 전역 상태에 업데이트시킬 경우

`addMatcher` 메소드를 작성하여 특정 데이터가 로드되었을 때 해당하는 전역 상태를 업데이트시킬 수 있다.

```typescript
const gameSlice = createSlice({
  name: "game",
  initialState: {
    // ...
  },
  reducers: {
    // ...
  },
  extraReducers(builder) {
    builder.addMatcher(
      gameApi.endpoints.getGames.matchFulfilled,
      (state, action) => {
        // state의 특정 속성을 업데이트시킨다.
        state.game.someProperty = action.payload.data.response;
      }
    );
  },
});
```

## `fakeBaseQuery`

`fetchBaseQuery`에서는 네트워크 요청에 필요한 API 주소를 명시해야 한다. 만약 프로젝트에서 GraphQL을 사용하거나, 파이어베이스와 같은 백엔드 개발 플랫폼을 사용할 경우, `fakeBaseQuery`로 대신할 수 있다. 이때 `query` 메소드 대신 `queryFn`으로 데이터를 가져오는 로직을 작성할 수 있다.

```typescript
const api = createApi({
  baseQuery: fakeBaseQuery<CustomError>(),
  endpoints: (builder) => ({
    loadData: builder.query<ResponseType, QueryParameter>({
      queryFn() {
        // 데이터를 불러오는 로직을 작성한다.
        try {
          const response: ResponseType = externalApi();
          return { data: response };
        } catch (err) {
          // 데이터를 불러오지 못했을 때 에러 데이터를 반환한다.
          return {
            error: {
              status: 500,
              data: "ERROR MESSAGE",
            },
          };
        }
      },
    }),
  }),
});
```
