---
title: "React 18 API `useSyncExternalStore`을 도입하기"
description: "`useSyncExternalStore` Hooks을 적용해야 하는 이유와 경위를 다뤘습니다."
image:
createdAt: "2023-05-12T16:08:38.629Z"
updatedAt:
author: "nw.lee"
draft: false
tags:
  [
    "React",
    "React Hooks",
    "useSyncExternalStore",
    "Local Storage",
    "TypeScript",
    "Window",
    "Navigator",
    "Subscribe",
    "getSnapshot",
  ]
---

# `useSyncExternalStore`

## React 17까지

프론트엔드에서는 다크모드 적용여부, 최신 검색어 목록과 같이 웹 사이트를 종료해도 관련 데이터가 남아있도록 하기 위해 로컬 스토리지를 활용할 수 있다. React 18 이전까지는 리액트 컴포넌트나 훅에서 로컬 스토리지에 직접 접근해도 문제가 발생하지 않았다. 로컬 스토리지는 데이터가 키 밸류 형태로 저장된다. 데이터가 업데이트되면 커스텀 이벤트를 발생시켜 같은 키를 공유하는 타 컴포넌트도 데이터를 갱신하도록 해야 한다.

```ts
const StorageEvent = new CustomEvent("localstorage", {
  bubbles: true,
});

const useLocalStorage = <T extends unknown = unknown>(
  key: string,
  defaultValue?: T
) => {
  const [state, setState] = useState<T | undefined>();

  useEffect(() => {
    const storedItem = window.localStorage.getItem(key);
    if (storedItem !== null && storedItem !== undefined) {
      const parsed = JSON.parse(storedItem) as T;
      setState(parsed);
      return;
    }
    if (defaultValue !== null && defaultValue !== undefined) {
      const newText = JSON.stringify(defaultValue);
      window.localStorage.setItem(key, newText);
      return;
    }
  }, [key, defaultValue]);

  useEffect(() => {
    const handler = function (event: StorageEvent) {
      const storedItem = window.localStorage.getItem(key) as string;
      if (storedItem === null || storedItem === undefined) {
        setState(undefined);
        return;
      }

      const parsed = JSON.parse(storedItem);
      setState(parsed);
    };
    window.addEventListener("localstorage", handler);

    return () => {
      window.removeEventListener("localstorage", handler);
    };
  }, [key]);

  const updateState = (newValue: T) => {
    window.localStorage.setItem(key, JSON.stringify(newValue));
    window.dispatchEvent(StorageEvent);

    setState(newValue);
  };

  const deleteState = () => {
    window.localStorage.removeItem(key);
    window.dispatchEvent(StorageEvent);

    setState(undefined);
  };
};
```

해당 코드가 작동하는 과정은 다음과 같이 정리할 수 있다.

1. `useLocalStorage` 리액트 훅이 호출되면 첫 번째 `useEffect`가 호출된다. 먼저 로컬 스토리지에 키에 대한 데이터가 있는지 확인한다. 데이터가 없으면 매개변수로 넘겨준 `defaultValue`로 업데이트한다.

2. `updateState` 함수는 같은 타입의 새로운 데이터를 받아서 로컬 스토리지에 저장하도록 한다. 여러 컴포넌트에서 해당 Hooks을 호출하는 경우 한 컴포넌트에서 상태가 변경되어도 다른 컴포넌트에서는 상태가 업데이트되었는지 알 수 없다.

3. `window.dispatchEvent` 커스텀 메소드로 이벤트를 발생시킨다. 자바스크립트의 이벤트는 최상위 요소로 전파되기 때문에 `window` 객체에서 이벤트를 처리하도록 한다. 이벤트를 발생시키기 전 로컬 스토리지에 새로운 데이터를 저장한다.

4. 이벤트 핸들러 함수에서는 로컬 스토리지에서 새로 저장된 데이터를 가져와 `setState` 함수로 상태를 업데이트한다.

리액트 18 이전까지는 컴포넌트를 동기적으로 렌더링한다. UI 코드가 작성된 순서대로 실행된다. 리액트 18부터는 동시성(Concurrent) 기능이 구현되었다. 리액트 라이프사이클을 따르지 않는, 외부에 있는 데이터에 접근하게 되면 일관되지 않은 데이터가 렌더링되는 문제점이 있다고 한다.

아직 프로젝트를 진행하면서 동시성 렌더링에 대해 문제를 맞닥뜨린 적은 없지만 리액트 서버 컴포넌트도 나오는 마당에 미리 대비하는 게 좋을 것 같아서 이슈에 대해서 더 찾아봤다.

```ts
import { useEffect, useSyncExternalStore } from "react";

const cache = (<T extends unknown>() => new Map<string, T>())();
const handlers = new Set<(key: string) => unknown>();
const IS_PRIMITIVE = "__IS_PRIMITIVE__";

const isPrimitive = (value: unknown) => {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value === "string") {
    return true;
  }
  if (typeof value === "boolean") {
    return true;
  }
  return false;
};

const useLocalStorage = <T>(key: string, defaultValue?: T) => {
  useEffect(() => {
    const cachedValue = cache.get(key);
    if (cachedValue !== null && cachedValue !== undefined) {
      return;
    }
    const storedItem = window.localStorage.getItem(key);
    if (storedItem !== null && storedItem !== undefined) {
      const parsed = JSON.parse(storedItem);
      if (parsed[IS_PRIMITIVE]) {
        cache.set(key, parsed[key]);
      } else {
        cache.set(key, parsed);
      }
      return;
    }
    if (defaultValue !== null && defaultValue !== undefined) {
      if (isPrimitive(defaultValue)) {
        const wrapped = {
          [IS_PRIMITIVE]: true,
          [key]: defaultValue,
        };
        window.localStorage.setItem(key, JSON.stringify(wrapped));
      } else {
        window.localStorage.setItem(key, JSON.stringify(defaultValue));
      }
      cache.set(key, defaultValue);
    }
  }, []);
  const onSubscribe = (onStoreChange: () => unknown) => {
    const onChange = (cacheKey: string) => {
      if (cacheKey === key) {
        onStoreChange();
      }
    };
    handlers.add(onChange);
    return () => {
      handlers.delete(onChange);
    };
  };

  const onSnapshot = () => {
    return cache.get(key) as T;
  };

  const state = useSyncExternalStore(onSubscribe, onSnapshot);
  const setState = (newValue: T) => {
    cache.set(key, newValue);
    if (isPrimitive(newValue)) {
      const wrapped = { [IS_PRIMITIVE]: true, [key]: newValue };
      window.localStorage.setItem(key, JSON.stringify(wrapped));
    } else {
      window.localStorage.setItem(key, JSON.stringify(newValue));
    }

    for (const handler of handlers) {
      handler(key);
    }
  };

  useEffect(() => {
    const onStorage = (event: StorageEvent) => {
      if (event.key === key) {
        for (const handler of handlers) {
          handler(key);
        }
      }
    };

    window.addEventListener("storage", onStorage);
    return () => {
      window.removeEventListener("storage", onStorage);
    };
  }, [key]);

  return [state, setState] as const;
};

export default useLocalStorage;
```

새로 작성한 `useLocalStorage`는 `key` 문자열과 `defaultValue`를 매개변수로 받는다. `key`를 받는 이유는 로컬 스토리지에서 다른 데이터와 구분하기 위함이다.

`useSyncExternalStore` Hooks은 두 가지 함수를 매개변수로 받는다.

- `onSubscribe` 함수는 외부 데이터 스토어를 구독하고 구독을 해제하는 함수를 반환한다. 매개변수로 받는 콜백 함수는 스토어가 변경되면 반드시 호출되어야 한다.
- `onSnapshot` 함수는 외부 스토어가 변경되었을 때 데이터를 리턴할 수 있다.

`useLocalStorage` 훅 외부에는 2개의 변수가 선언되어 있다.

- `handlers` 변수는 `Set` 객체로서 외부 데이터 스토어가 업데이트되었을 때 호출해야 할 함수를 보관하는 역할을 한다. 여러 컴포넌트에서 `useLocalStorage` 훅을 호출하더라도 전부 같은 `handlers` 객체를 참조한다.
- `cache` 변수는 키 밸류 데이터를 저장할 수 있는 `Map` 객체다.

`onChange` 함수는 `cacheKey` 문자열을 매개변수로 받는다. `cacheKey`가 매개변수로 받은 `key`와 같으면 상태를 업데이트시킨다.

상태를 업데이트시키는 `setState`는 새로운 데이터를 로컬 스토리지에 저장한 후 `handlers`에 저장된 함수를 하나씩 호출한다. 이 `handler` 함수에 넘겨준 키 문자열이 `useLocalStorage` 훅의 key 매개변수와 같은지 파악한다.

`onStoreChange` 콜백 함수는 `onChange` 커스텀 함수에서 호출한다.

## 결론

`useSyncExternalStore` 리액트 훅으로 컴포넌트 외부에 있는 데이터들과 안전하게 동기화할 수 있다.
